local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LocalPlayer = Players.LocalPlayer

-- Debug logging function
local function log(message)
    print("[QESpam Debug]: " .. tostring(message))
end

-- Check for keypress support
local keypressSupported = false
if keypress and keyrelease then
    keypressSupported = true
    log("Executor supports keypress/keyrelease.")
elseif VirtualInputManager then
    keypressSupported = true
    log("VirtualInputManager detected as fallback.")
else
    warn("[QESpam Warning]: No keypress support. Spamming will not work.")
end

-- Wait for PlayerGui
local success, PlayerGui = pcall(function()
    return LocalPlayer:WaitForChild("PlayerGui", 10)
end)
if not success or not PlayerGui then
    warn("[QESpam Error]: Failed to find PlayerGui: " .. tostring(PlayerGui))
    return
end
log("PlayerGui found.")

-- Create UI
local ScreenGui
success, ScreenGui = pcall(function()
    local gui = Instance.new("ScreenGui")
    gui.Name = "QESpamUI"
    gui.Parent = PlayerGui
    gui.ResetOnSpawn = false
    gui.IgnoreGuiInset = true
    return gui
end)
if not success or not ScreenGui then
    warn("[QESpam Error]: Failed to create ScreenGui: " .. tostring(ScreenGui))
    return
end
log("ScreenGui created.")

local Frame = Instance.new("Frame")
Frame.Size = UDim2.new(0, 180, 0, 200) -- Adjusted height
Frame.Position = UDim2.new(0.5, -90, 0.5, -100)
Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
Frame.BackgroundTransparency = 0.2
Frame.BorderSizePixel = 0
Frame.Active = true
Frame.Draggable = true
Frame.Parent = ScreenGui
log("Frame created.")

-- Add gradient
local UIGradient = Instance.new("UIGradient")
UIGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 30)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 50, 50))
}
UIGradient.Parent = Frame

-- Add rounded corners
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = Frame

-- Add shadow
local Shadow = Instance.new("ImageLabel")
Shadow.Size = UDim2.new(1, 20, 1, 20)
Shadow.Position = UDim2.new(0, -10, 0, -10)
Shadow.BackgroundTransparency = 1
Shadow.Image = "rbxassetid://6014261993"
Shadow.ImageTransparency = 0.7
Shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
Shadow.ScaleType = Enum.ScaleType.Slice
Shadow.SliceCenter = Rect.new(38, 38, 262, 262)
Shadow.Parent = Frame

-- Title label
local TitleLabel = Instance.new("TextLabel")
TitleLabel.Size = UDim2.new(0, 160, 0, 30)
TitleLabel.Position = UDim2.new(0, 10, 0, 10)
TitleLabel.BackgroundTransparency = 1
TitleLabel.Text = "Q/E Spam Control"
TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleLabel.TextSize = 16
TitleLabel.Font = Enum.Font.GothamBold
TitleLabel.Parent = Frame

-- Toggle button
local ToggleButton = Instance.new("TextButton")
ToggleButton.Size = UDim2.new(0, 160, 0, 35)
ToggleButton.Position = UDim2.new(0, 10, 0, 50)
ToggleButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.Text = "Q/E Spam: OFF"
ToggleButton.TextSize = 14
ToggleButton.Font = Enum.Font.Gotham
ToggleButton.Parent = Frame
local ToggleCorner = Instance.new("UICorner")
ToggleCorner.CornerRadius = UDim.new(0, 8)
ToggleCorner.Parent = ToggleButton

-- Status indicator
local StatusIndicator = Instance.new("Frame")
StatusIndicator.Size = UDim2.new(0, 10, 0, 10)
StatusIndicator.Position = UDim2.new(0, 10, 0, 12.5)
StatusIndicator.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
StatusIndicator.BorderSizePixel = 0
StatusIndicator.Parent = ToggleButton
local StatusCorner = Instance.new("UICorner")
StatusCorner.CornerRadius = UDim.new(0.5, 0)
StatusCorner.Parent = StatusIndicator

-- Hide button
local HideButton = Instance.new("TextButton")
HideButton.Size = UDim2.new(0, 160, 0, 35)
HideButton.Position = UDim2.new(0, 10, 0, 95)
HideButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
HideButton.TextColor3 = Color3.fromRGB(255, 255, 255)
HideButton.Text = "Hide UI"
HideButton.TextSize = 14
HideButton.Font = Enum.Font.Gotham
HideButton.Parent = Frame
local HideCorner = Instance.new("UICorner")
HideCorner.CornerRadius = UDim.new(0, 8)
HideCorner.Parent = HideButton

-- Record Key button
local RecordKeyButton = Instance.new("TextButton")
RecordKeyButton.Size = UDim2.new(0, 160, 0, 25)
RecordKeyButton.Position = UDim2.new(0, 10, 0, 140)
RecordKeyButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
RecordKeyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
RecordKeyButton.Text = "Record Key"
RecordKeyButton.TextSize = 14
RecordKeyButton.Font = Enum.Font.Gotham
RecordKeyButton.Parent = Frame
local RecordKeyCorner = Instance.new("UICorner")
RecordKeyCorner.CornerRadius = UDim.new(0, 8)
RecordKeyCorner.Parent = RecordKeyButton

-- Hotkey label
local HotkeyLabel = Instance.new("TextLabel")
HotkeyLabel.Size = UDim2.new(0, 160, 0, 20)
HotkeyLabel.Position = UDim2.new(0, 10, 0, 120)
HotkeyLabel.BackgroundTransparency = 1
HotkeyLabel.Text = "UI Hotkey: H"
HotkeyLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
HotkeyLabel.TextSize = 12
HotkeyLabel.Font = Enum.Font.Gotham
HotkeyLabel.TextXAlignment = Enum.TextXAlignment.Left
HotkeyLabel.Parent = Frame

-- Disable button
local DisableButton = Instance.new("TextButton")
DisableButton.Size = UDim2.new(0, 160, 0, 25)
DisableButton.Position = UDim2.new(0, 10, 0, 165)
DisableButton.BackgroundColor3 = Color3.fromRGB(80, 40, 40)
DisableButton.TextColor3 = Color3.fromRGB(255, 255, 255)
DisableButton.Text = "Disable Script"
DisableButton.TextSize = 14
DisableButton.Font = Enum.Font.Gotham
DisableButton.Parent = Frame
local DisableCorner = Instance.new("UICorner")
DisableCorner.CornerRadius = UDim.new(0, 8)
DisableCorner.Parent = DisableButton

-- Variables
local isSpamming = false
local isUIVisible = true
local currentHotkey = Enum.KeyCode.H
local spamCoroutine = nil
local hotkeyConnection = nil
local toggleConnection = nil
local isRecordingKey = false

-- Store original button sizes
local buttonSizes = {
    [ToggleButton] = UDim2.new(0, 160, 0, 35),
    [HideButton] = UDim2.new(0, 160, 0, 35),
    [RecordKeyButton] = UDim2.new(0, 160, 0, 25),
    [DisableButton] = UDim2.new(0, 160, 0, 25)
}

-- Animation functions
local function animateButton(button, hover)
    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
    local originalSize = buttonSizes[button]
    local scale = hover and UDim2.new(0, originalSize.X.Offset * 1.05, 0, originalSize.Y.Offset * 1.05) or originalSize
    local color = hover and Color3.fromRGB(80, 80, 80) or Color3.fromRGB(60, 60, 60)
    if button == DisableButton then
        color = hover and Color3.fromRGB(100, 50, 50) or Color3.fromRGB(80, 40, 40)
    end
    local success, err = pcall(function()
        TweenService:Create(button, tweenInfo, {Size = scale, BackgroundColor3 = color}):Play()
    end)
    if not success then
        log("Button animation failed: " .. tostring(err))
    end
end

local function animateUI(visible)
    local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local goal = visible and {BackgroundTransparency = 0.2, Position = UDim2.new(0.5, -90, 0.5, -100)} or 
        {BackgroundTransparency = 1, Position = UDim2.new(0.5, -90, 0.5, -140)}
    local success, err = pcall(function()
        local tween = TweenService:Create(Frame, tweenInfo, goal)
        tween:Play()
        if not visible then
            tween.Completed:Wait()
            Frame.Visible = false
        else
            Frame.Visible = true
        end
    end)
    if not success then
        log("UI animation failed: " .. tostring(err))
    end
end

-- Function to simulate key press
local function simulateKey(keyCode, keyName)
    if not keypressSupported then
        log("Keypress not supported, skipping: " .. keyName)
        return false
    end
    local success, err = pcall(function()
        if keypress and keyrelease then
            keypress(keyCode)
            wait(0.005)
            keyrelease(keyCode)
        else
            VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
            wait(0.01)
            VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
        end
    end)
    if not success then
        warn("[QESpam Error]: Keypress failed for " .. keyName .. ": " .. tostring(err))
        return false
    end
    log("Simulated keypress: " .. keyName)
    return true
end

-- Function to spam Q and E keys alternately
local function spamQE()
    log("Starting spamQE coroutine.")
    while isSpamming do
        local deltaTime = RunService.RenderStepped:Wait()
        if deltaTime > 0.033 then -- Skip if FPS < 30
            log("Low FPS detected, skipping keypress.")
            continue
        end
        if not simulateKey(0x51, "Q") then
            isSpamming = false
            ToggleButton.Text = "Q/E Spam: OFF"
            StatusIndicator.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
            break
        end
        wait(0.02) -- 20ms delay
        if not isSpamming then break end
        if not simulateKey(0x45, "E") then
            isSpamming = false
            ToggleButton.Text = "Q/E Spam: OFF"
            StatusIndicator.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
            break
        end
        wait(0.02) -- 20ms delay
    end
    log("spamQE coroutine stopped.")
end

-- Toggle spam function
local function toggleSpam()
    isSpamming = not isSpamming
    ToggleButton.Text = isSpamming and "Q/E Spam: ON" or "Q/E Spam: OFF"
    StatusIndicator.BackgroundColor3 = isSpamming and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    if isSpamming then
        if spamCoroutine then
            coroutine.close(spamCoroutine)
        end
        spamCoroutine = coroutine.create(spamQE)
        coroutine.resume(spamCoroutine)
    else
        if spamCoroutine then
            coroutine.close(spamCoroutine)
            spamCoroutine = nil
        end
    end
    log("Spam toggled: " .. tostring(isSpamming))
end

-- Toggle UI visibility
local function toggleUIVisibility()
    isUIVisible = not isUIVisible
    HideButton.Text = isUIVisible and "Hide UI" or "Show UI"
    animateUI(isUIVisible)
    log("UI visibility toggled: " .. tostring(isUIVisible))
end

-- Update hotkey
local function updateHotkey(newKeyCode)
    if hotkeyConnection then
        hotkeyConnection:Disconnect()
        hotkeyConnection = nil
    end
    local success, keyName = pcall(function()
        return newKeyCode.Name
    end)
    if success and keyName then
        currentHotkey = newKeyCode
        HotkeyLabel.Text = "UI Hotkey: " .. keyName
        hotkeyConnection = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
            if not gameProcessedEvent and input.KeyCode == currentHotkey then
                toggleUIVisibility()
            end
        end)
        log("Hotkey updated to: " .. keyName)
    else
        HotkeyLabel.Text = "UI Hotkey: Invalid"
        wait(1)
        HotkeyLabel.Text = "UI Hotkey: " .. currentHotkey.Name
        log("Invalid hotkey attempted.")
    end
end

-- Record key function
local function startRecordingKey()
    if isRecordingKey then return end
    isRecordingKey = true
    RecordKeyButton.Text = "Press a Key..."
    local connection
    local success, err = pcall(function()
        connection = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
            if not gameProcessedEvent and input.KeyCode ~= Enum.KeyCode.Unknown then
                updateHotkey(input.KeyCode)
                isRecordingKey = false
                RecordKeyButton.Text = "Record Key"
                connection:Disconnect()
            end
        end)
    end)
    if not success then
        log("Key recording failed: " .. tostring(err))
        isRecordingKey = false
        RecordKeyButton.Text = "Record Key"
    end
end

-- Disable script function
local function disableScript()
    isSpamming = false
    if spamCoroutine then
        coroutine.close(spamCoroutine)
        spamCoroutine = nil
    end
    if hotkeyConnection then
        hotkeyConnection:Disconnect()
        hotkeyConnection = nil
    end
    if toggleConnection then
        toggleConnection:Disconnect()
        toggleConnection = nil
    end
    local success, err = pcall(function()
        ScreenGui:Destroy()
    end)
    if not success then
        log("ScreenGui destroy failed: " .. tostring(err))
    end
    log("Script disabled.")
end

-- Event connections
local success, err = pcall(function()
    ToggleButton.MouseButton1Click:Connect(toggleSpam)
    HideButton.MouseButton1Click:Connect(toggleUIVisibility)
    RecordKeyButton.MouseButton1Click:Connect(startRecordingKey)
    DisableButton.MouseButton1Click:Connect(disableScript)

    for _, button in pairs({ToggleButton, HideButton, RecordKeyButton, DisableButton}) do
        button.MouseEnter:Connect(function()
            animateButton(button, true)
        end)
        button.MouseLeave:Connect(function()
            animateButton(button, false)
        end)
    end

    toggleConnection = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
        if not gameProcessedEvent and input.KeyCode == Enum.KeyCode.R then
            toggleSpam()
        end
    end)

    LocalPlayer.AncestryChanged:Connect(function()
        disableScript()
    end)
end)
if not success then
    log("Event connection failed: " .. tostring(err))
    disableScript()
    return
end

-- Initial hotkey setup
updateHotkey(Enum.KeyCode.H)

log("Script initialized successfully.")
